
{% extends "base.html" %}
 {% load staticfiles %}

 {% block scripts %}
 <link rel="stylesheet" type="text/css" href="{% static 'd3GraphCSS.css' %}"/>
 <script src="{% static 'spin.min.js' %}"></script>
 {% endblock scripts %}

 {% block controls %}

 <select id="linkTypeSelector">
 {% for linkType in linkTypes %}
 <option value="{{linkType.name}}">{{linkType.name}}</option>
 {% endfor %}
 </select>

 <select id="nodeTypeSelector">
 {% for nodeType in nodeTypes %}
 <option value="{{nodeType.name}}">{{nodeType.name}}</option>
 {% endfor %}
 </select>
 
 <button type="button" onclick="storeNodePos()">StoreNodePos</button>

 <button type="button" onclick="resetNodePos()">ResetNodePos</button>

 <div id="spinner-box"></div>

 {% endblock controls %}


 {% block d3Script %}
 <script src="http://d3js.org/d3.v3.min.js"></script>
 <script src="http://code.jquery.com/jquery-1.10.1.min.js"></script>
 <script>

 var spinOpts = {
     lines: 8,
     length: 10,
     width: 5,
     radius: 5,
     corners: 0.5,
     rotate: 0,
     direction: 1,
     color: '#000',
     speed: 1,
     trail: 40,
     shadow: false,
     hwaccel: false,
     className: 'spinner',
     zIndex: 2e9,
     top: 'auto',
     left: 'auto'
 };
 var spinner = new Spinner(spinOpts);
 var spinnerTarget = document.getElementById('spinner-box');

 var width = 1020;
 var height = 800;

var force = d3.layout.force()
    .size([width,height])
    .charge(-400)
    .linkDistance(40)
    .on("tick", tick);

var drag = force.drag()
    .on("dragstart", dragstart);


zooom = d3.behavior.zoom().scaleExtent([-5,8]).on("zoom", zoom)
var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
    .append("g")
    .call(zooom)
    .append("g");

svg.append("rect")
    .attr("class","overlay")
    .attr("width",width)
    .attr("height",height);


var linkVis = svg.append("svg:g");
var nodeVis = svg.append("svg:g");
var rectVis = svg.append("svg:g");


var link = linkVis.selectAll(".link");
var node = nodeVis.selectAll(".node");

// This keeps track of the last node the mouse was over.
var currentObjectMouse = null;
// This keeps track of the last node the user clicked on.
var currentObjectClick = null;




d3.json("{% url 'base.views.getGraph' %}", function(error, graph){
    if(error){alert("Err: "+error);}
    force.nodes(graph.nodes)
         .links(graph.links)
         .start();    

    start();
});


// ::TODODone:: This function is duplicating everything when it's called! 
//          Find out why and fix this. Well, it was because of incorrect nesting in
//          the d3 calls. Each update was calling an append it shouldn't have, so the
//          nodes just kept getting stacked on there.
function start() {
    link = link.data(force.links());
    link.enter().append("line").attr("class","link");
    link.exit().remove();
    node = node.data(force.nodes());
    thing = node.enter().append("g").attr("class","node").classed("fixed", function(d){return(d.fixed===1)}).call(drag);
    thing.append("circle")
	.attr("r", 12);
    thing.append("text")
	.attr("dx", 12)
	.attr("dy", ".15em")
	.text(function(d){return d.name});
    thing.on("mouseover", function(){
	if(currentObjectMouse!=null){
	    d3.select(currentObjectMouse).select("text").classed("mouseOverSelected",false);
	}
	d3.select(this).select("text").classed("mouseOverSelected",true);
	currentObjectMouse = this;
    });
    thing.on("mousedown", function(){
	if(currentObjectClick!=null){
	    d3.select(currentObjectClick).select("text").classed("clickSelected",false);
	}
	d3.select(this).select("text").classed("clickSelected",true);
	currentObjectClick = this;
    });
    node.exit().remove();
    force.start();
}
    


function tick() {
    link.attr("x1", function(d){return d.source.x;})
	.attr("y1", function(d){return d.source.y;})
	.attr("x2", function(d){return d.target.x;})
	.attr("y2", function(d){return d.target.y;});

    //node.attr("cx", function(d){return d.x;})
    //    .attr("cy", function(d){return d.y;});
    node.attr("transform", function(d){return "translate("+d.x+","+d.y+")";});
}

function dragstart(d){
 
    d.fixed = true;
    d3.select(this).classed("fixed", true);
    d3.event.sourceEvent.stopPropagation();
}

globalScale = null;
globalTranslate = null;
function zoom(){
    console.log(d3.event);
    if(d3.event===null){
	var trans = zooom.translate();
	var scale = zooom.scale();
	svg.attr("transform", "translate("+trans+")scale("+scale+")");
	globalScale = scale;
	globalTranslate = trans;
	
    }
    else if(d3.event.sourceEvent.shiftKey==true){
	if(d3.event.sourceEvent.wheelDelta > 0){
	    // one thing
	    var gravity = force.gravity();
	    force.gravity( gravity * 1.05 );
	}else{
	    // other thing
	    var gravity = force.gravity();
	    force.gravity( gravity * 0.95 );
	}
	start();
	if(globalScale != null && globalTranslate != null){
	    zooom.scale(globalScale);
	    zooom.translate(globalTranslate);
	}
	d3.event.sourceEvent.stopPropagation();
    } else {
	svg.attr("transform", "translate("+d3.event.translate+")scale("+d3.event.scale+")");
	globalScale = d3.event.scale;
	globalTranslate = d3.event.translate;
    }
}

// Handling the key events.
// This might be a bit rough for a while as I learn how to do this.
d3.select("body")
    .on("keydown", function(){
	var kcode = d3.event.keyCode;
	if(kcode==76){ // This is 'l'
	    flashText("adding Link");
	    addLink();
        }else if(kcode==82){ // This is 'r' for 'removeLink'
            flashText("removing Link");
            removeLink();
	}else if(kcode==65){ // This is 'a' for 'add'
	    flashText("adding Node");
	    addNode();
	}else if(kcode==69){ // This is 'e' for 'edit'
	    flashText("editing Node");
	    editNode();
	}else if(kcode==85){ // This is 'u' for 'unfix'
	    flashText("unfixing node");
	    unfixNode();
	}else{
	    flashText(""+kcode);
	}
    });
function flashText(txt){
    svg.append("text").attr("x","100")
	.attr("y","100")
	.style("font-size","26px")
	.text(""+txt)
	.transition().duration(2000)
	.style("font-size","5px")
	.style("fill-opacity",".1")
	.remove();
}

function unfixNode(){
    var mouseyNode = d3.select(currentObjectMouse);
    mouseyNode.classed("fixed", false);
    mouseyNode.data()[0].fixed=0;
    start();
}

function addLink(){
    var clickIndex = currentObjectClick.__data__.index;
    var clickName = currentObjectClick.__data__.name;
    var mouseIndex = currentObjectMouse.__data__.index;
    var mouseName = currentObjectMouse.__data__.name;
    var linkType = $('#linkTypeSelector')[0].options[$('#linkTypeSelector')[0].selectedIndex].value;
    function addLinkCallback(){
        var oldLinks = force.links();
        var newLinks = oldLinks.push({"source":clickIndex, "target":mouseIndex});
        start();
    }
    addLinkToDB(clickName, mouseName, linkType, addLinkCallback);
}
function removeLink(){
    var clickIndex = currentObjectClick.__data__.index;
    var clickName = currentObjectClick.__data__.name;
    var mouseIndex = currentObjectMouse.__data__.index;
    var mouseName = currentObjectMouse.__data__.name;
    var currentLinks = force.links();
    function compare(link1, link2){
        var l1s = link1.source.name;
        var l1t = link1.target.name;
        var l2s = link2.source;
        var l2t = link2.target;
        if((l1s === l2s) || (l1s === l2t)) {
            if((l1t === l2t) || (l1t == l2s)) {
                return true;
            }
        }
        return false;
    }
    function remove(arr, item){
        for(var i=arr.length; i--;){
            if(compare(arr[i], item)){
                arr.splice(i,1);
            }
        }
    }
    function removeLinkCallback(){
        remove(currentLinks, {"source":clickName, "target":mouseName});
        start();
    }
    removeLinkFromDB(clickName, mouseName, removeLinkCallback);
}

function addLinkToDB(aN, bN, lType, addLinkCallback){
    $.ajax({
        beforeSend: function(){
            spinner.spin(spinnerTarget);
        },
        complete: function(){
            spinner.stop();
        },
        type: 'POST',
        url: 'http://localhost/organizer/addLink/',
        data: {'from':aN, 'to':bN, 'type':lType, 'csrfmiddlewaretoken':'{{csrf_token}}'}, // data
        success: function(data, txtStatus, jqXHR){
            if(data['status']==="success"){
                addLinkCallback();
            }else{
                alert("Error Occurring on server. Check js console.");
                console.log(" "+data)
                console.log(" "+txtStatus)
                console.log(" "+jqXHR)
            }
        },
        error: function(e1,e2,e3){
            alert("Add Link Ajax Failed: "+e1+" \n"+e2+" \n"+e3);
        }
    });
}

function doAjax(datas, url, successFunk){
    // successFunk must be sf(retData, txtStatus, jqXHR){...}
    var datas_mod = datas
    datas_mod['csrfmiddlewaretoken'] = '{{csrf_token}}';
    $.ajax({
	beforeSend: function(){
	    spinner.spin(spinnerTarget);
	},
	complete: function(){
	    spinner.stop();
	},
	type:'POST',
	url: url,
	data: datas_mod,
	success: successFunk,
	error: function(e1,e2,e3){
	    alert("Ajax Failed: "+e1+" \n"+e2+" \n"+e3);
	    globalE1 = e1;
	    globalE2 = e2;
	    globalE3 = e3;
	}
    });
}

 
function removeLinkFromDB(aN, bN, removeLinkCallback){ 
    doAjax({'from':aN, 'to':bN}, 
	   "http://localhost/organizer/removeLink/",
	   function(data, txtStatus, jqXHR){
	       if(data['status']==="success"){
		   removeLinkCallback();
	       }else{
		   alert("Error in removeLinkFromDB. Use js console.");
	       }
	   });
}

function storeNodePos(){

 
    function addNode(n){
	izFixed = d3.select(n).property('fixed')===1;
	var x = {'nodeName':n.name,'x':n.x, 'y':n.y, 'fixed':izFixed};
	console.log(n);
	return(x);
    }
    
    doAjax({'nodeList':JSON.stringify(node.data().map(function(d){return(addNode(d));})),
	    'posNodeType':'gtd_position',
	    'posLinkType':'gtd_position'}, 
	   "http://localhost/organizer/fixNodePos/",
	   function(data, txtStatus, jqXHR){
	       if(data['status']==='success'){
		   //storeNodeCallback();
	       }else{
		   alert("Error in storeNodePos. Use js console.");
		   blah = data;
	       }
	   });
    //alert("called storeNodePos");
}

function resetNodePos(){

    doAjax({'posNodeType':'gtd_position', 'posLinkType':'gtd_position'},
	   "http://localhost/organizer/resetAllNodePos/",
	   function(d, t, j){
	       if(d['status']==='success'){
		   //resetNodeCallback();
	       }else{
		   alert("Error in resetNodePos. Use js console.");
	       }
	   });
    //alert("called resetNodePos");
}

function addNode(){
    alert("addNode not yet implemented");
}

function editNode(){
    alert("editNode not yet implemented");
}

</script>
{% endblock d3Script %}
